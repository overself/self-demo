# SpringBatch与Postgresql的性能分析

## 性能改善
在分布式系统或并行处理环境中，增加并行度并不总是线性提升性能。程序中可并行部分和不可并行（串行）部分的比例决定了通过并行化能获得的最大加速比（Amdahl定律）。

并发性能指的是系统同时处理多个请求的能力。在应用系统与数据库交互的场景下，这意味着系统能够同时处理多个用户或客户端的请求而不出现显著的性能下降。

### **1、并发性能通常受到以下因素的影响：**
- CPU核心数量
- 内存容量
- 网络带宽
- 数据库的索引优化
- 应用程序的代码效率
- 操作系统和数据库管理系统本身的并发处理能力

应用服务器和数据库服务器的CPU配置需求主要由各自处理的工作负载类型决定。两者在系统架构中的角色不同，因此它们的资源需求也会有所不同。
一般而言，数据库服务器对CPU的要求通常更高，原因如下：

1. **复杂的数据处理**：<br>
数据库服务器需要处理复杂的查询、索引操作、事务管理以及并发控制，这些都需要大量的CPU资源。特别是当涉及到复杂的分析查询、实时数据分析或大规模数据处理时，数据库服务器的CPU性能直接影响到数据处理的速度和效率。

2. **高并发请求**：<br>
数据库服务器经常需要同时处理大量并发的读写请求。多核心CPU能够更好地支持并行处理，提高数据库的吞吐量和响应时间。

3. **数据一致性**：
数据库需要确保数据的一致性和完整性，这涉及到锁机制、日志记录和故障恢复，这些操作都是CPU密集型的。

相比之下，应用服务器通常侧重于业务逻辑的执行、用户界面渲染和网络通信，虽然也需要一定的CPU资源，但往往更依赖于网络I/O、内存和快速响应用户请求的能力。
应用服务器的CPU需求可能会根据具体的应用类型和负载而变化，但通常不如数据库服务器那样对CPU有极高的要求。

然而，这并不意味着应用服务器的CPU配置可以很低。在某些情况下，例如高性能计算、实时数据处理或图形密集型应用，应用服务器的CPU配置甚至可能与数据库服务器相当或更高。

### 在PostgreSQL中利用视图`pg_stat_activity`获得当前连接数和会话数

- 1. **查询当前所有连接的总数**:
    ~~~postgresql
    SELECT COUNT(*) FROM pg_stat_activity;
    ~~~

- 2. **查询当前活跃的会话数**:
   如果你想排除处于`idle`状态的会话，你可以添加一个WHERE子句来过滤出活跃的会话：
   ~~~sql
   SELECT COUNT(*) FROM pg_stat_activity WHERE state <> 'idle';
   ~~~

- 3. **查看详细的连接信息**:
   如果你想要看到每个连接的详细信息，比如PID、用户名、数据库名、状态等，你可以直接查询`pg_stat_activity`：
    ~~~sql
    SELECT * FROM pg_stat_activity;
    ~~~
    ~~~ text
    `pg_stat_activity`视图包含了如下的列：
    - `pid`: 进程ID。
    - `usesysid`: 用户ID。
    - `usename`: 用户名。
    - `application_name`: 应用程序名。
    - `client_addr`: 客户端地址。
    - `client_hostname`: 客户端主机名。
    - `client_port`: 客户端端口。
    - `backend_start`: 后端启动时间。
    - `xact_start`: 事务开始时间。
    - `query_start`: 查询开始时间。
    - `state_change`: 状态改变时间。
    - `wait_event_type`: 等待事件类型。
    - `wait_event`: 等待事件。
    - `state`: 当前状态（例如：active, idle）。
    - `backend_xid`: 后端事务ID。
    - `backend_xmin`: 后端最小事务ID。
    - `query`: 当前执行的查询。
    ~~~

- **连接与会话的关系**
  - **连接** 是物理层面上客户端与数据库服务器之间的点对点通信链路。
  - **会话** 是逻辑层面上用户与数据库之间的交互过程。
  - 一个连接可以支持一个或多个会话，具体取决于数据库系统的设计。
  - 连接数和会话数通常正相关，增加会话可能会导致更多的连接被使用。

### 在PostgreSQL中如何监控当前连接数和会话数
#### 1. 设置`track_activity_query_size`
为了获取更详细的查询信息，你可以设置`track_activity_query_size`参数以记录查询文本的大小。这可以帮助你理解正在执行的查询是什么样的。

#### 2. 使用`pg_stat_user_connections`
这个视图可以用来查看特定用户或所有用户的连接数：
~~~sql
SELECT * FROM pg_stat_user_connections;
~~~
#### 3、第三方数据库监控工具
第三方工具，如PgBouncer、pgAdmin、EnterpriseDB的Postgres Enterprise Manager等，
它们提供了图形界面和更高级的功能来监控和管理PostgreSQL的连接和会话。

### HikariCP数据库连接池
Spring Batch框架中使用HikariCP作为数据库连接池的情况下，合理设置连接池的参数对于确保良好的性能和资源管理至关重要。以下是一些步骤和考虑因素：
#### 1. 理解你的工作负载
- **任务特性**: 分析Spring Batch作业的特性，包括数据量、查询复杂度、读写比例等。
- **并发策略**: 了解Spring Batch的并发策略，例如分区处理时每个分区的并发级别。
  线程池的最大线程数可以作为参考，因为每个线程可能需要一个数据库连接。当并行分区数为15时，意味着理论上你可能需要至少15个连接来满足所有线程的数据库操作需求。
#### 2. 评估资源
- **系统资源**: 查看你的服务器硬件规格，如CPU核心数、内存大小、磁盘I/O能力和网络带宽。
  常见的经验公式是根据CPU核心数来设置连接池的最大连接数，例如：`maximumPoolSize = (CPU core number * 2) + 1`。
  按照这个公式，对于8核服务器，最大连接数大约是15（8 * 2 + 1 = 17），但这通常适用于较低并发的场景。
- **数据库配置**: 确定PostgreSQL的`max_connections`配置，以及数据库服务器的资源限制。

### 3. 数据库连接限制
- **数据库的`max_connections`**
  通常不超过数据库的`max_connections`值的80%左右。

#### 4. 初始配置
- **最大连接数 (`maximumPoolSize`)**: 初始设置可以基于资源评估，通常不超过数据库的`max_connections`值的80%左右。
- **最小空闲连接数 (`minimumIdle`)`: 可以设置为较小的值，如5或10，确保总有一些连接始终可用。
- **空闲连接超时 (`idleTimeout`)`: 设置合理的超时时间，以平衡资源使用和连接回收。

#### 5. 监控和测试
- **应用监控**: 使用Spring Actuator或其他工具监控Spring Batch作业的性能和资源使用情况。
- **数据库监控**: 监控PostgreSQL的`pg_stat_activity`，以及系统资源使用情况。
- **压力测试**: 使用工具如JMeter或Gatling进行压力测试，观察不同连接数设置下的性能表现。

#### 6. 逐步调整
- **增加连接数**: 逐渐增加`maximumPoolSize`，观察性能提升是否明显，同时注意资源利用率。
- **减少连接数**: 如果发现连接数过多导致资源浪费或数据库响应变慢，尝试减少`maximumPoolSize`。

### 7. 考虑分区和并发
- **分区策略**: 如果Spring Batch作业采用分区策略，确保连接数足够覆盖所有分区的并发需求。
- **线程和连接**: 调整Spring Batch的线程池大小，以匹配数据库连接池的大小，避免线程等待连接的情况。

#### 7. 性能权衡
- **响应时间 vs. 资源使用**: 找到响应时间最短和资源使用最经济的平衡点。
- **长期稳定性**: 确保设置能够维持长期的稳定性和可扩展性。

#### 连接池数评估结果
    - **估算结果**
    基于上述规则，一个合理的最大连接数设置可能是在15到35之间。这是因为线程池最大数为15，而服务器的硬件配置（尤其是内存）足够强大，可以支持更多的连接，
    结合Batch并行处理，所有batch应用的连接数最大不能接近数据库的最大连接数2000。

    - **推荐设置** 
    如果应用主要是读取操作且读取操作比较轻量，可以尝试设置`maximumPoolSize`为25至35之间。
    如果应用包含较多写入操作或较重的读取操作，由于这些操作可能需要更长的时间，可以考虑将`maximumPoolSize`设置为15至25之间，
    这个范围允许应用在高峰时处理更多的并发请求，同时留有足够的空间以免数据库服务的过载，此外，还考虑了数据库连接的开销和监理新连接的成本。

### HikariCP中一些最重要的配置参数
1. **`maximumPoolSize`**
    - **描述**: 控制连接池中最大连接数。
    - **默认值**: 10
    - **作用**: 设定最大并发连接的数量，避免数据库连接过度消耗资源。
   - **调整建议**: 增加`maximumPoolSize`以确保有足够的连接供应用程序使用。但是，这个值不能无限增加，因为每个数据库连接都会消耗服务器资源（如内存）。最佳实践是将其设置为数据库服务器的`max_connections`参数的70%-80%，并考虑到服务器资源的限制。

2. **`minimumIdle`**
    - **描述**: 指定连接池中最小的空闲连接数。
    - **默认值**: 10
    - **作用**: 确保即使在低负载时也有一定数量的连接可供立即使用。
    - **调整建议**: 保持一定数量的连接始终处于空闲状态可以帮助减少创建新连接的延迟。通常设置为与`maximumPoolSize`成比例的较小数值，但也要考虑应用的负载模式和连接的平均使用时间。


3. **`idleTimeout`**
    - **描述**: 连接在池中闲置多久后会被回收。
    - **默认值**: 600000ms (10分钟)
    - **作用**: 控制连接的有效寿命，避免长时间闲置的连接占用资源。
    - **调整建议**: 可能希望更快地回收空闲连接，以释放资源给新请求。但是，频繁的连接创建和销毁也会带来开销。调整`idleTimeout`需要找到一个平衡点，既不过早回收连接，也不让过多的空闲连接占用资源。

4. **`maxLifetime`**
    - **描述**: 池中连接的最长生命周期。
    - **默认值**: 1800000ms (30分钟)
    - **作用**: 限定连接的使用时间，防止连接老化，强制周期性的连接刷新。
    - **调整建议**: 定期替换旧连接有助于避免潜在的数据库连接问题。`maxLifetime`应该设置得足够长以避免频繁的连接重建，但也要短到足以防止连接老化。

5. **`connectionTimeout`**
    - **描述**: 客户端等待从池中获取连接的最长时间。
    - **默认值**: 30000ms (30秒)
    - **作用**: 设置等待获取连接的超时时间，超出这个时间将抛出异常。
    - **调整建议**: 减少`connectionTimeout`可以更快地发现连接池资源耗尽的问题，促使应用采取恢复措施。然而，过短的超时时间可能导致更多的异常和重试，增加系统负担。

6. **`leakDetectionThreshold`**
    - **描述**: 设置连接泄漏检测的阈值。
    - **默认值**: 0 (禁用)
    - **作用**: 防止连接被应用程序代码意外地长时间持有。
    - **调整建议**: 在高并发环境中，设置非零值的`leakDetectionThreshold`可以帮助检测和报告连接泄漏，这是高并发场景下常见的问题。
7. **`keepaliveTime`**
   - **描述**: 保持连接活跃的时间间隔。
   - **调整建议**: 适当的`keepaliveTime`可以确保连接在空闲时仍然有效，避免网络或数据库端的超时断开。

### postgreSql数据CPU及内存评估
构建一台PostgreSQL数据库服务器时，需要基于以下因素评估：
### 1. **确定工作负载**
- 分析数据库的用途：是用于OLTP（在线事务处理）还是OLAP（在线分析处理），或者是混合工作负载？
- 了解预期的并发用户数量和查询复杂度。

### 2. **评估CPU需求**
- **查询类型**：对于大量复杂的查询或数据分析，更多的CPU核心有助于并行处理，提高查询效率。
- **CPU频率**：除了核心数量，CPU的时钟频率也很重要，更高的频率意味着每个核心的处理能力更强。
- 使用`wmic cpu get NumberOfCores`（Windows）或`lscpu`（Linux）等命令检查现有服务器的CPU核心数作为参考点。
- **核心数**：对于OLTP负载，建议至少有4-8个物理核心；对于OLAP或混合负载，考虑16个或更多核心，

### 3. **评估内存需求**
- **缓冲与缓存**：PostgreSQL使用共享内存作为缓存，以减少磁盘I/O。更大的缓存可以显著提高性能，尤其是对于频繁访问的数据。
- **工作内存**：`work_mem`参数影响每个查询的排序和哈希操作所使用的内存，较大的值可以加快查询速度。
- **有效缓存大小**：目标是将整个数据库或者其大部分放入内存中，以减少磁盘I/O。考虑数据库的大小和数据访问模式。
- **系统开销**：除了数据库，还要预留内存给操作系统和其他应用程序。
- 目标是将常用数据（“热数据”）全部放入内存中。一个常见规则是为数据量的2-3倍分配内存，以考虑到共享缓冲区、排序操作、查询缓存等。
### 4. **测试和调优**
- 在部署前，使用压力测试工具如PgBench或HammerDB模拟生产环境，测试服务器配置。
- 调整`postgresql.conf`中的参数，如`shared_buffers`, `effective_cache_size`, `work_mem`等，以优化性能。


### 示例配置
一个示例配置，适用于中等到大型PostgreSQL数据库服务器：

- **CPU**：2x Intel Xeon Gold 或 AMD EPYC处理器，每个至少16核心，总核心数32+。
- **内存**：至少128GB，对于大型数据库考虑256GB或更高。
